<h2><a href="https://www.postgresql.org/docs/14/ddl-constraints.html#DDL-CONSTRAINTS-FK" target="_blank"><code>REFERENCES</code></a>.</h2><p>Las claves ajenas o for&aacute;neas son columnas de una tabla que se relacionaban con la clave primaria (o incluso con la clave candidata) de otra tabla.</p><p>Al crear la tabla, tendremos que indicar, de alguna forma, cu&aacute;l es la clave ajena. Lo haremos &quot;haciendo referencia&quot; a la tabla y los atributos de donde procede.</p><p>Imagina que hemos creado la tabla <code>MATCHES</code> con el siguiente comando:</p><blockquote><pre><code>CREATE TABLE MATCHES (<br />    COD_MATCH INTEGER PRIMARY KEY,<br />    MATCH_DATE DATE<br />);</code></pre></blockquote><p>En nuestra tabla <code>USERS</code> vamos a tener una clave ajena procedente de la tabla <code>MATCHES</code> que ser&aacute; su <code>COD_MATCH</code>, por tanto tendremos que hacer referencia a &eacute;ste:</p><blockquote><pre><code>CREATE TABLE USERS (<br />    COD_MATCH INTEGER<br />        CONSTRAINT Cod_Match_FK<br />        REFERENCES MATCHES(COD_MATCH)<br />);</code></pre></blockquote><p>Si el campo al que hace referencia es clave principal en su tabla no es necesario indicar el nombre del campo:</p><blockquote><pre><code>CREATE TABLE USERS (<br />    COD_MATCH INTEGER<br />        CONSTRAINT Cod_Match_FK<br />        REFERENCES MATCHES<br />);</code></pre></blockquote><p>Al relacionar campos necesitamos que el dato del campo que es clave ajena en una tabla (que llamaremos secundaria) previamente haya sido incluido en su tabla de procedencia donde es clave primaria o candidata. En nuestro ejemplo, cualquier <code>COD_MATCH</code> que incluyamos en la tabla <code>USERS</code>, deber&iacute;a estar previamente en la tabla de la que procede, es decir, en la tabla <code>MATCHES</code>. <strong>A esto se le llama Integridad Referencial.</strong></p><p>Esto puede crear algunos errores, pues puede ocurrir lo siguiente:</p><ul><li>Si hacemos referencia a una tabla que no est&aacute; creada: el DBMS buscar&aacute; la tabla referenciada y al no encontrarla dar&aacute; fallo. Esto se soluciona creando en primer lugar las tablas que no tengan claves ajenas.</li><li>Si queremos borrar las tablas tendremos que proceder al contrario, borraremos las tablas que tengan claves ajenas antes.</li></ul><h3>Ejercicio:</h3><p>Supongamos que tenemos que almacenar datos de <code>MODULES</code>, seg&uacute;n la siguiente definici&oacute;n:</p><blockquote><pre><code>CREATE TABLE MODULES (<br />    CODE INTEGER PRIMARY KEY,<br />    NAME VARCHAR(100),<br />    FACULTY CHAR(3)<br />);</code></pre></blockquote><p>La impartici&oacute;n de cada uno de esos <code>MODULES</code> corresponde a una de las <code>FACULTIES</code>, cuyos datos se almacenan en la siguiente tabla:</p><blockquote><pre><code>CREATE TABLE FACULTIES (<br />    COD_FACULTY CHAR(3) PRIMARY KEY,<br />    NAME VARCHAR(100)<br />);</code></pre></blockquote><p>Crea las tablas y relaci&oacute;nalas a trav&eacute;s de una clave ajena.</p>