<h2>Kısıtlama <code>UNIQUE</code>.</h2><p>Sütundaki değerleri tekrar edememekle ilgilendiğimiz durumlar olacaktır, bu durumlarda kısıtlamayı kullanacağız. <a HREF="https: //www.postgresql.org/docs/14/ddl-constraints.html#DDL-CONSTRAINTS-UNIQUE-CONSTRAINTS" target="_blank"><code>EŞSİZ</code></a >. PostgreSQL, bu kısıtlama etkinleştirildiğinde otomatik olarak bir dizin oluşturur ve devre dışı bırakıldığında onu siler.</p><p>Ayrıca bu kısıtlama için yazmanın iki olası yolu var, bir örnekle görelim. Tablomuzdaki <code>Login</code> alanının benzersiz olacağını varsayalım. Oluşturduğumuz tabloya dahil edeceğiz. Şuna benzer:</p><blockquote><pre><code>TABLO KULLANICILARI OLUŞTUR (<br /> VARCHAR(25) Girişi Yap<br /> CONSTRAINT Use_Log_UK EŞSİZ<br />);</code>< /pre ></blockquote><p>Başka bir yol görelim:</p><blockquote><pre><code>TABLO KULLANICILARI OLUŞTUR (<br /> Giriş VARCHAR(25) UNIQUE<br />);</ code>< /pre></blockquote><p>Bu kısıtlamayı aynı anda birkaç alana da koyabiliriz, örneğin, <code>Login</code> ve <code>EMAIL</code> olmak istiyorsak benzersiz, bunu şöyle ifade edebiliriz:</p><blockquote><pre><code>TABLO KULLANICILARI OLUŞTUR (<br /> Giriş VARCHAR(25),<br /> EMAIL VARCHAR(100),<br /> CONSTRAINT Users_UK UNIQUE (Login, EMAIL )<br />);</code></pre></blockquote><p>Fark ederseniz, <code>EMAIL</code> veri türünün arkasında bir virgül vardır. , çünkü kısıtlama o alandan bağımsızdır ve birkaçında ortaktır. Bu nedenle <code>UNIQUE</code>'den sonra kısıtlamadan etkilenen alanların adlarını parantez içinde verdik.</p><h3>Alıştırma:</h3><p><code>EMAIL gibi </ code> iki farklı öğrencide tekrarlanmamalıdır, önceki alıştırmadaki tabloya iki öğrencinin aynı e-postayı almasını engelleyen bir kısıtlama ekleyin.</p>