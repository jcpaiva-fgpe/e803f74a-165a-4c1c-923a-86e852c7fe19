<p>Bazen bir tabloya zorunlu olarak dahil edilecek bir veriye ihtiyaç duyduğumuzda, diğer zamanlarda alanlardan birini birincil veya yabancı anahtar olarak tanımlamamız gerekecek. Tüm bunları, diğer seçeneklere ek olarak tabloyu tanımladığımızda yapabileceğiz.</p><p><strong>kısıtlama</strong>, bir veya birkaç sütunun zorunlu olarak karşılaması gereken bir koşuldur.</p><p> p><p>Oluşturduğumuz her kısıtlamanın bir adı olacak, biz koymazsak kullandığımız DBMS öyle yapacak. Tanımlamamıza yardımcı olacak ve her şema (kullanıcı) için benzersiz olan bir ad vermemiz uygundur. Bir şekilde tablonun adını, ilgili alanları ve kısıtlama türünü tablo adına eklemek iyi bir fikirdir.</p><h3>Sözdizimi:</h3><p>Standart SQL'deki sözdizimi şöyledir: aşağıdakiler:</p><blockquote><pre><code>TABLO TABLOSU OLUŞTURMA (<br /> Sütun1 Veri_Türü<br /> [KISIT kısıtlama_adı]<br /> [NULL DEĞİL]<br /> [EŞSİZ]< br /> [PRİMARY ANAHTAR]<br /> [YABANCI ANAHTAR]<br /> [VARSAYILAN değer]<br /> [REFERANSLAR tablosuAdı [(sütun [, sütun ])]<br /> [SİLME KASKADINDA]]< br /> [KONTROL koşulu],<br /> Sütun2 Veri_Türü<br /> [KISITLAMA kısıtlama_adı]<br /> [NULL DEĞİL]...<br /> ,...<br />);</code ></pre></blockquote><p>Bir örnek görelim:</p><blockquote><pre><code>TABLO KULLANICILARI OLUŞTUR (<br /> Giriş VARCHAR(15) CONSTRAINT usu_log_PK PRIMARY KEY,<br / > Şifre VARCHAR(8) NOT NULL,<br /> HIRE_DATE DATE DEFAULT CURRENT_DATE<br />);</code></pre></blockquote><h2>Kısıtlama <a href="https://www . postgresql.org/docs/14/ddl-constraints.html#id-1.5.4.6.6" target="_blank"><code>NU DEĞİL LL</code></a>.</h2><p>Bu kısıtlama ile o sütunu bir değere ya da aynı olana zorlayacağız, belirli bir tablodaki bir sütun için boş değerleri yasaklıyor.< /p ><p>Veri tipini koyduktan sonra <code>NOT NULL</code> kelimesini ekleyerek alanı oluşturduğumuzda veya değiştirdiğimizde koyabiliriz.</p><p>Evet <code> tablosuna KULLANICILAR</code > <code>BIRTH_DATE</code> alanının zorunlu olmasını istiyoruz, şöyle görünür:</p><blockquote><pre><code>TABLO KULLANICILARI OLUŞTUR (<br /> DOĞUM_TARİHİ TARİHİ) <br /> CONSTRAINT Use_BirDate_NN NOT NULL);</code></pre></blockquote><p>veya başka bir şekilde:</p><blockquote><pre><code>TABLO KULLANICILARI OLUŞTUR (< br /> BIRTH_DATE DATE NOT NULL);</code></pre></blockquote><p><code>1 * NULL</code> eşit olduğundan işlemlerde null değerlere dikkat etmeliyiz. <code>NULL</code>.</p><p>Alıştırma:</p><p>Önceki alıştırmada gördüğümüz <code>STUDENTS</code> tablosuna kısıtlamalar ekleyeceğiz. Nitelikler ve türleri yukarıda belirtilenlerle aynı olmalıdır:</p><ul><li><code>ID</code>: ondalık olmadan 8 basamağa kadar olan sayıları içerir.</li><li >< code>NIF</code>: 9 karaktere kadar sayı ve harflerden oluşan bir kombinasyon içerir.</li><li><code>LAST_NAME</code>: daha önce bu özelliğin uzunluğunu zaten sınırlamıştık 50 karaktere kadar. </li><li><code>FIRST_NAME</code>: Daha önce bu özelliğin uzunluğunu 25 karakterle sınırlamıştık.</li><li><code>BIRTH_DATE</code>: mantıksal olarak, bir tarih depolar .</li><li><code>MİLLİLİK</code>: Maksimum uzunluğu 30 olan karakter dizilerini depolar.</li><li><code>EMAIL</code>: 100 karaktere kadar dizeleri de saklar.</li><li><code>PHONE</code>: boşluk veya önek olmadan yalnızca rakamları saklar.</li></ul><p>Ayrıca , tablonun her satırının <code> LAST_NAME</code>, <code>FIRST_NAME</code> ve <code>EMAIL</code> özniteliklerinin bir değere sahip olmasını zorlamalısınız, buna izin verilmez ve bu niteliklerle ilişkili değer <code>NULL</code>'dur.</p>